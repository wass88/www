第1部 R言語の基礎
========================================================
author: wass80
date: 2017-03-01
autosize: true

自己紹介
===
* 情報学科計算機 新3回 wass80
* 趣味: ボドゲ, ボカロ
* 後期のプロジェクトは御飯作ってばっかりだった気がする
* 去年に引き続きバイトでのネタ

R言語の利点
===

* 豊富なライブラリ

このスライドの目的
===

R言語を書かざるをえなくなった人が

* 独特な仕様を理解してつまづきを減らす
* データ解析する
* ビジュアライゼーションする
* メタプログラミングする

スライドの構成
===

* 第1部はR言語の基本
* 第2部は実際にデータ解析
* 第3部はメタプログラミング

環境構築
===

起動
===

この型は?
===


```r
42
```

```
[1] 42
```
の型はわかりますか

答え
===

```r
42
```

```
[1] 42
```

**1要素の数値型ベクトル**

**ベクトルの挙動を知らずにRは書けない**

変数束縛
===

`識別子 <- 式`

```r
x <- 1
y <- 1
x + y
```

```
[1] 2
```

Rの変数束縛
===

ドットも識別子。逆向き束縛`->`もある。snake_case推奨

```r
a.b <- 2
1 -> z
a.b + z
```

```
[1] 3
```

現在の環境を表示

```r
ls()
```

```
[1] "a.b" "x"   "y"   "z"  
```

表示されるものされないもの
===

束縛は結果を返さないように見える

```r
a <- 1
```
しかしこれは書ける

```r
b <- a <- 1
b
```

```
[1] 1
```

```r
a
```

```
[1] 1
```

===

実は結果があるが, 表示されないだけ

括弧をつけると結果が表示される

```r
(a <- 1)
```

```
[1] 1
```

結果を表示させないようにも出来る

```r
invisible(1 + 2)
```

基本型
===

```r
TRUE  # 論理値(logical)
1L # 数値(integer) Lをつけないとdouble
1.1   # 小数(double)
"1.1" # 文字列(character)
```

上から下に暗黙の型変換が起きる

vector
===
ベクトル


```r
1:25
```

```
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
[24] 24 25
```

ベクトル操作
===
5番目を取り出す (**初めの要素は1番目**)

```r
a <- 2:7
a[5] 
```

```
[1] 6
```

5番目を変更

```r
a[5] <- 42
a
```

```
[1]  2  3  4  5 42  7
```

1要素のベクトル
===
**スカラー(値)は1要素のベクトル**

```r
5
```

```
[1] 5
```

1要素のベクトルの1要素目の1要素目の1要素目

```r
42[1][1][1]
```

```
[1] 42
```


ベクトルの結合
===

```r
c(2:5,3:1) # Concat(結合)のC
```

```
[1] 2 3 4 5 3 2 1
```

1要素のベクトルの結合

```r
c(1,4,3) # ベクトルのリテラル表現
```

```
[1] 1 4 3
```

* **ベクトルはネストできない**
* **ベクトルをベクトルの要素に出来ない**

ベクトルの型変換
===
ベクトルは同じ型を持つように型変換される

```r
c(TRUE, 1, 1.1)
```

```
[1] 1.0 1.0 1.1
```

```r
c(1:5, "a")
```

```
[1] "1" "2" "3" "4" "5" "a"
```

NULL
===
0要素を表す特殊なNULL型ベクトル

```r
NULL
```

```
NULL
```

```r
c(NULL, 1:4, NULL)
```

```
[1] 1 2 3 4
```

NA
===
* どの型のベクトルの要素にもなれる
* 欠損値(Not Available)
* NULLと混同しないように
* 殆どの結果がNA

```r
c(1,2,NA,4)
```

```
[1]  1  2 NA  4
```

```r
NA == NA
```

```
[1] NA
```

まとめ: ベクトル
===

* **スカラーは1要素のベクトル**
* ベクトルの要素は同じ型
* ベクトルの要素をベクトルに出来ない

ベクトル化された関数(N->N)
===
ベクトルを与えることで要素ごとに計算する

```r
sqrt(2)
```

```
[1] 1.414214
```

```r
sqrt(c(1,4,9,16,25))
```

```
[1] 1 2 3 4 5
```

ベクトルの2項演算(NxN->N)
===

```r
1 + 3
```

```
[1] 4
```

```r
c(1,2,3) + c(2,4,6)
```

```
[1] 3 6 9
```

```r
c(1,1,1) == c(3,1,2)
```

```
[1] FALSE  TRUE FALSE
```

リサイクル
===
要素が足りない場合, 繰り返して補う

```r
1:5 + 3 # 1:5 + c(3,3,3,3,3)
```

```
[1] 4 5 6 7 8
```

```r
1:2 + 1:6 # c(1,2,1,2,1,2) + 1:6
```

```
[1] 2 4 4 6 6 8
```

```r
c(3,1,2) == 1 # c(3,1,2) == c(1,1,1)
```

```
[1] FALSE  TRUE FALSE
```

縮約関数(N->1)
===
ベクトルを取ってスカラーを返す関数

```r
sum(1:10)
```

```
[1] 55
```

ベクトル化の嬉しさ
===
モンテカルロ法で円周率を求める例

```r
s <- 1000
sum(runif(s)^2+runif(s)^2 <= 1)*4/s
```

```
[1] 3.172
```

解説
===

```r
runif(5) # Random UNIFication
```

```
[1] 0.92023413 0.51047968 0.05835193 0.62349040 0.05021647
```

```r
sum(c(T,F,T,T,F)) # Tは1 Fは0に型変換
```

```
[1] 3
```

```r
sum(runif(s)^2+runif(s)^2 <= 1)*4/s
```

```
[1] 3.12
```

ループだとダメなの?
===

```r
res <- 0
for(i in 1:s){
  res <- res + (runif(1)^2+runif(1)^2 <= 1)
}
res * 4 / s
```

```
[1] 3.176
```

速度比較
===



```r
library(microbenchmark)
s <- 1000
bench <- microbenchmark(vec_f(s), loop_f(s))
```

(microsecond)

|       |   min|    lq|  mean| median|    uq|   max|
|:------|-----:|-----:|-----:|------:|-----:|-----:|
|vec_f  |   282|   285|   329|    299|   302|  2610|
|loop_f | 12200| 14600| 15700|  15000| 15400| 83500|

* ベクトル化しないと50倍から100倍遅くなるケースがある
* 従ってベクトル化出来ないならRで書くべきではない

Rを使うべきではない？？？
===

* スクリプト言語としてRはほぼ最遅
* Rの紹介本でPerlやPythonが紹介されていることがある
* Rで書きにくい処理は無理に書くべきではない
* 統計処理用の言語だと割り切ろう

関数
===
* `function`で作る
* イコールは名前付き引数の構文

```r
sub <- function(x,y) x - y
sub(5,3)
```

```
[1] 2
```

```r
sub(y = 10, x = 5) # 名前付き引数
```

```
[1] -5
```

factor(因子)
===

```r
(sex <- factor(c("M","F","F"), levels = c("M", "F")))
```

```
[1] M F F
Levels: M F
```

* 有限集合表現
* 内部的には**integerのvector**であることを覚えておく


```r
str(sex)
```

```
 Factor w/ 2 levels "M","F": 1 2 2
```

list
===
連想配列



```r
(obj <- list(one=1, two=c(1,1,1), three="3"))
```

```
$one
[1] 1

$two
[1] 1 1 1

$three
[1] "3"
```

listへのアクセス
===

```r
print_list(obj) #list表示用に定義した関数
```

```
$one: 1; $two: c(1, 1, 1); $three: 3
```

```r
obj$one
```

```
[1] 1
```

```r
obj[["two"]]
```

```
[1] 1 1 1
```

* 異なる型でも格納できる
* `$`か`[[`でアクセス

属性
===
* オブジェクトの付加情報

```r
print_list(attributes(obj)) # List
```

```
$names: c("one", "two", "three")
```

```r
print_list(attributes(sex)) # Factor
```

```
$levels: c("M", "F"); $class: factor
```

* `str`では見えない情報が見える

S3 ジェネリック
===
* 付加情報`class`を利用したジェネリックな関数
* 同じ名前の関数でも`class`によって関数を呼び分ける
* 例: `str`関数は引数によって実際は以下の関数に振り分けられる

```r
methods("str")
```

```
[1] str.data.frame*       str.Date*             str.default*         
[4] str.dendrogram*       str.logLik*           str.POSIXt*          
[7] str.Rcpp_stack_trace* str.uneval*           str.unit.arithmetic* 
see '?methods' for accessing help and source code
```

S3の例
===

```r
my_method <- function(x) UseMethod("my_method")
my_method.a <- function(o) cat("called by a", o$a)
my_method.default <- function(o) cat("called by defalut")
obj <- list(x = 1)
class(obj) <- "a" # class属性を"a"に
my_method(obj) # my_method.a が呼ばれる
```

```
called by a
```

```r
class(obj) <- "b" # class属性を"b"に
my_method(obj) # 無いのでmy_method.defualtが呼ばれる
```

```
called by defalut
```

S3ガバガバでは?
===
* ガバガバ。ただ, 自分でいじる必要はない
* S3はの中身はリストだったりベクトルだったりする


```r
num <- c(1,2,3)
class(num)
```

```
[1] "numeric"
```

```r
class(num) <- "Date"
str(num) # 日付に!?
```

```
 Date[1:3], format: "1970-01-02" "1970-01-03" "1970-01-04"
```

S4 クラス
===
* S3を厳密にしたもの


```r
setClass("Person",
  slots=list(name="character", age="integer"))
str(me <- new("Person", name="wass", age=20L))
```

```
Formal class 'Person' [package ".GlobalEnv"] with 2 slots
  ..@ name: chr "wass"
  ..@ age : int 20
```

S4 クラスのスロット
===
`@`でアクセスする

```r
me@name
```

```
[1] "wass"
```

```r
me@age
```

```
[1] 20
```

S4の安全性
===
* 存在しないスロット作れない
* スロットと同じ型しか代入できない

```r
try(me@weight <- 80)
try(me@age <- "a")
```

中身がリストのS3の場合どちらも出来てしまう

* S3と同様にメソッドが定義できる
* S4は継承の仕組みもあるが割愛

まとめ: List, S3, S4
===
* Listは連想配列, `$`でアクセス
* S3は`class`属性を使った簡易ジェネリック
* S4はS3から少し厳密になったクラス

* S3とS4どっちが良いかは終わらない議論
* ちなみにGoogleはS3派
* (GoogleにはRコーディング規約が存在する)

大まとめ
===
* だいたいベクトル
* ベクトルで計算しよう
* S3, S4はライブラリを使うための説明
